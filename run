#!/usr/bin/env lua
--| It is an automation system for development and code publishing
--|

local sh = require('etc.build.sh')
local luaVersions = {"5.1","5.2","5.3","5.4"}
local sepline = "*******************************"
local sepline2= "-------------------------------"
local devadir = "./doctest"
local testdir = "./doctest"

local luabin = {
  ["5.1"] = sh.whereis("lua%s","5.1","51"),
  ["5.2"] = sh.whereis("lua%s","5.2","52"),
  ["5.3"] = sh.whereis("lua%s","5.3","53"),
  ["5.4"] = sh.whereis("lua%s","5.4","54"),
}

local action = {} -- public actions

function test_compile(luaver)
  print(("Compiling for Lua %s"):format(luaver))
  print(sepline)
  sh.exec("luarocks --tree ./tree --lua-version %s make ./etc/rockspec/wax-latest-1.rockspec",luaver)
end

function test_lua(luaver)
  local lbin  = luabin[luaver]
  local lpath = ("./tree/share/lua/%s/?.lua;./tree/share/lua/%s/?/init.lua"):format(luaver,luaver)
  local cpath = ("./tree/lib/lua/%s/?.so" ):format(luaver)

  local p = io.popen("find "..testdir.." -name '*.lua' 2> /dev/null","r")
  if p == nil then return end

  print(("\nTesting with Lua %s"):format(luaver))
  print(sepline)
  testnum = 0
  local file = p:read()
  while file do
    testnum = testnum + 1
    print(("\nTEST %s "):format(file))
    sh.exec(
      [[ TZ=UTC+0 %s -e 'package.path=%q package.cpath=%q' %q ]],
      lbin, lpath, cpath, file
    )
    file = p:read()
  end
  print( "\n".. sepline2
       , "\n".. ("Total: %d tests"):format(testnum)
       , "\n".. sepline2
       , "\n\n\n")
end

function docker_names()
  local files = sh.rexec("ls etc/docker/*.dockerfile")
  local names = {}
  for i,dfile in ipairs(files) do
    names[dfile:gsub("^.*/",""):gsub(".dockerfile$","")] = 1
  end
  return names
end

function docker_image(name)
  name = name or "luawax_debian"
  if sh.OS ~= "Linux" then
    print("This action requires a Linux machine host")
    os.exit(1)
  end
  if not docker_names()[name] then
    action.dlist()
    os.exit(1)
  end

  local name = sh.rexec("docker images | grep %q | awk '{print $1}'",name)[1]
  if not name then
    print(("Try build first with:\n\n\t./run dbuild %s\n"):format(arg[2]))
    os.exit(1)
  end
end


--
-- Public actions
-- Below functions are used as actions called directly from Ex:
-- ./run dlist

--| * clean      Remove compile and test stage artifacts
function action.clean()
  print("Cleaning project")
  sh.exec("rm -rf ./tree ./wax ./out ./lua ./luarocks ./lua_modules ./.luarocks")
  sh.exec("rm -rf ./lua ./luarocks ./lua_modules ./.luarocks")
  sh.exec("find ./src -name '*.o' -delete")
end


--| * deva       Retrieve the list of documented items
function action.deva()
  cmd = ([[
    cat $(find %s -name '*.lua') \
    | grep '\--@'|cut -d' ' -f2- 2> /dev/null
  ]]):format(devadir)
  os.execute(cmd)
end


--| * devamd     Retrieve list of code signatures in markdown
function action.devamd()
  cmd = ([[
    for i in $(find %s -name '*.lua'); do
      grep -A1 '^\(--@\|--{ #\|--| #\)' $i ;
    done | sed 's/^--@\s*\(\([^(]\+\).*\)\s*$/\n###### \2\n\n`\1`\n/g;s/^--[}{|]\?\s*//g'
  ]]):format(devadir)
  os.execute(cmd)
end


--| * test       Compile, and run Lua deva files
function action.test()
  for i,luaver in ipairs(luaVersions) do
    test_compile(luaver)
    test_lua(luaver)
  end
end


--| * sparse     Run semantic parser for C
function action.sparse()
  local cmd = table.concat {
    [[ sparse -Wsparse-error ]],
    [[ -Wno-declaration-after-statement ]],
    [[ -Wsparse-all ]],
    [[ -I/usr/include/lua%s ]],
    [[ -I./src ]],
    [[ -I./src/lib ]],
    [[ src/*c 2>&1 | grep -v "unknown attribute\|note: in included file" | tee /dev/stderr | wc -l ]]
  }
  print("\nRunning sparse")
  print(sepline)
  for _,luaver in ipairs(luaVersions) do
    print (("\n - Targeting C for Lua %s"):format(luaver))
    if (sh.rexec(cmd:format(luaver)))[1] ~= "0" then
      os.exit(1)
    end
  end
  print("")
  print(sepline,"\nSparsed OK! :)\n")
end


--| * dlist      List available Docker confs
function action.dlist()
  print("\nAvailable docker confs:\n")
  for name,_ in pairs(docker_names()) do print(name) end
end


--| * dbuild     Build Docker instance for tests
function action.dbuild()
  local img = docker_image(arg[2])
  if img then
    sh.rexec([[docker rmi "%s:latest"]],img)
    sh.exec([[docker build -t "%s:latest" -f "etc/docker/%s.dockerfile" .]], imgname, imgname)
  else
    action.dlist()
  end
end


--| * drun       Run command on Docker test instance
docker_run_cmd = [[docker run -ti --rm --mount=type=bind,source=%q,target=/devel %q %s]]
function action.drun()
  local img = docker_image(arg[2])

  local runcmd = docker_run_cmd:format(sh.PWD, img, "bash")
  os.execute(runcmd)
end


--| * dtest      Run Lua deva files through the Docker test instance
function action.dtest()
  local strgetimg = "docker images | grep %q | awk '{print $1}'"
  local strcmd    = [[bash -c "cd /devel && TERM=%q ./run test || exit 1; ./run clean"]]
  local strnotimg = "Try build first with:\n\n\t./run dbuild %s\n"

  local imgname = arg[2] or "luawax_debian"

  if imgname and docker_names()[imgname] then
    imgname = sh.rexec(strgetimg, imgname)[1]
    if not imgname then
      print(strnotimg:format(arg[2]))
      os.exit(1)
    end
    local cmd = strcmd:format(sh.TERM) -- run inside docker
    sh.exec(docker_run_cmd:format(sh.PWD, imgname, cmd))
  end
end

--| * install    Install the rockspec for all Lua versions
function action.install(rockspec)
  assert(rockspec, 'You need to specify a rockspec to install')
  local cmd = 'luarocks --lua-version %q make %q'
  for k,_ in pairs(luabin) do
    os.execute(cmd:format(k, rockspec))
  end
end

if action[arg[1]] then
  action[arg[1]]( (table.unpack or unpack)(arg,2) )
else
  local f = io.open(arg[0])
  repeat
    line = f:read()
    if line and line:find('^%-%-[|{}]%s?') == 1 then
        print(line:sub(5))
    end
  until not line
  f:close()
end
